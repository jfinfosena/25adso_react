#  Clase 4 Crear Componentes en React con Next.js (JavaScript) y Estilizar con CSS

## **¿Qué son las props en React?**

Las **props** (propiedades) son un mecanismo en React para pasar datos de un componente padre a un componente hijo. Son inmutables desde el componente hijo, lo que significa que el hijo no puede modificar las props directamente. Las props permiten que los componentes sean reutilizables y dinámicos.

- **Características principales**:
  - Son un objeto (`props`) que contiene los datos pasados al componente.
  - Pueden incluir cualquier tipo de dato: cadenas, números, objetos, arreglos, funciones, componentes, etc.
  - Son unidireccionales (del padre al hijo).
  - Son opcionales, pero se pueden establecer valores por defecto.

---

## **Formas de usar props en React**

### 1. **Pasar props básicas (cadenas, números, booleanos)**

Las props más simples son valores primitivos como cadenas, números o booleanos.

**Ejemplo**:

```jsx
// Componente hijo
function Saludo(props) {
  return <h1>Hola, {props.nombre}!</h1>;
}

// Componente padre
function App() {
  return <Saludo nombre="Juan" />;
}
```

**Explicación**:

- El componente padre `App` pasa la prop `nombre` con el valor `"Juan"`.
- El componente hijo `Saludo` accede a la prop a través del objeto `props` (`props.nombre`).
- En el renderizado, se muestra "Hola, Juan!".

**Salida**:
```
Hola, Juan!
```

---

### 2. **Desestructuración de props**

En componentes funcionales, puedes desestructurar las props directamente en los parámetros para escribir un código más limpio.

**Ejemplo**:

```jsx
// Componente hijo con desestructuración
function Saludo({ nombre, edad }) {
  return <h1>Hola, {nombre}. Tienes {edad} años.</h1>;
}

// Componente padre
function App() {
  return <Saludo nombre="Ana" edad={25} />;
}
```

**Explicación**:

- En lugar de usar `props.nombre` y `props.edad`, desestructuramos `{ nombre, edad }` en los parámetros.
- Esto hace que el código sea más legible y evita repetir `props.`.

**Salida**:
```
Hola, Ana. Tienes 25 años.
```

---

### 3. **Pasar objetos o arreglos como props**

Puedes pasar estructuras de datos más complejas, como objetos o arreglos, como props.

**Ejemplo**:

```jsx
// Componente hijo
function Perfil({ usuario }) {
  return (
    <div>
      <h2>{usuario.nombre}</h2>
      <p>Hobbies: {usuario.hobbies.join(", ")}</p>
    </div>
  );
}

// Componente padre
function App() {
  const usuario = {
    nombre: "María",
    hobbies: ["leer", "caminar", "programar"],
  };
  return <Perfil usuario={usuario} />;
}
```

 chatbot
**Explicación**:

- La prop `usuario` es un objeto que contiene `nombre` y `hobbies`.
- En el componente hijo, accedemos a las propiedades del objeto con `usuario.nombre` y `usuario.hobbies`.
- Usamos `join(", ")` para convertir el arreglo de hobbies en una cadena separada por comas.

**Salida**:
```
María
Hobbies: leer, caminar, programar
```

---

### 4. **Pasar funciones como props**

Puedes pasar funciones como props para permitir que el componente hijo ejecute lógica definida en el componente padre.

**Ejemplo**:

```jsx
// Componente hijo
function Boton({ onClick, texto }) {
  return <button onClick={onClick}>{texto}</button>;
}

// Componente padre
function App() {
  const manejarClick = () => {
    alert("¡Botón clicado!");
  };

  return <Boton onClick={manejarClick} texto="Clic aquí" />;
}
```

**Explicación**:

- La prop `onClick` es una función que se pasa desde el componente padre.
- Cuando el usuario hace clic en el botón, se ejecuta la función `manejarClick` definida en el componente padre.

**Salida**:
Un botón con el texto "Clic aquí" que muestra una alerta al hacer clic.

---

### 5. **Pasar componentes como props (Render Props)**

Puedes pasar un componente como prop, lo que permite renderizar contenido dinámico en el componente hijo.

**Ejemplo**:

```jsx
// Componente hijo
function Contenedor({ contenido }) {
  return <div>{contenido}</div>;
}

// Componente padre
function App() {
  const ContenidoDinamico = <h1>¡Este es un componente dinámico!</h1>;
  return <Contenedor contenido={ContenidoDinamico} />;
}
```

**Explicación**:
- La prop `contenido` es un elemento JSX que se renderiza directamente en el componente hijo.
- Esto es útil para patrones como "render props", donde el hijo decide cómo renderizar contenido pasado por el padre.

**Salida**:
```
¡Este es un componente dinámico!
```

---

### 6. **Props con children**

La prop especial `children` permite pasar contenido entre las etiquetas de apertura y cierre de un componente.

**Ejemplo**:

```jsx
// Componente hijo
function Caja({ children }) {
  return <div style={{ border: "1px solid black", padding: "10px" }}>{children}</div>;
}

// Componente padre
function App() {
  return (
    <Caja>
      <h1>Título dentro de la caja</h1>
      <p>Este es un párrafo.</p>
    </Caja>
  );
}
```

**Explicación**:

- Todo lo que se coloca entre `<Caja>` y `</Caja>` se pasa como la prop `children`.
- El componente hijo renderiza `children` donde desee.

**Salida**:
Un `div` con borde que contiene un título y un párrafo.

---

### 7. **Valores por defecto con defaultProps**

Puedes definir valores por defecto para las props usando `defaultProps` en componentes funcionales o de clase.

**Ejemplo (Componente funcional)**:

```jsx
// Componente hijo
function Saludo({ nombre }) {
  return <h1>Hola, {nombre}!</h1>;
}

Saludo.defaultProps = {
  nombre: "Invitado",
};

// Componente padre
function App() {
  return <Saludo />;
}
```

**Explicación**:

- Si no se pasa la prop `nombre`, se usa el valor por defecto `"Invitado"`.
- Esto es útil para evitar errores cuando las props no se proporcionan.

**Salida**:
```
Hola, Invitado!
```

---

### 8. **Validación de props con PropTypes**

Para asegurar que las props tengan el tipo y formato correctos, puedes usar la librería `prop-types`.

**Instalación**:
```bash
npm install prop-types
```

**Ejemplo**:

```jsx
import PropTypes from 'prop-types';

// Componente hijo
function Perfil({ nombre, edad, activo }) {
  return (
    <div>
      <h2>{nombre}</h2>
      <p>Edad: {edad}</p>
      <p>{activo ? "Activo" : "Inactivo"}</p>
    </div>
  );
}

Perfil.propTypes = {
  nombre: PropTypes.string.isRequired,
  edad: PropTypes.number.isRequired,
  activo: PropTypes.bool,
};

Perfil.defaultProps = {
  activo: false,
};

// Componente padre
function App() {
  return <Perfil nombre="Carlos" edad={30} />;
}
```

**Explicación**:

- `PropTypes.string.isRequired` asegura que `nombre` sea una cadena y sea obligatorio.
- `PropTypes.number.isRequired` asegura que `edad` sea un número y obligatorio.
- `PropTypes.bool` indica que `activo` debe ser un booleano, pero es opcional.
- Si no se pasa `activo`, se usa el valor por defecto `false`.

**Salida**:
```
Carlos
Edad: 30
Inactivo
```

---

### 9. **Props en componentes de clase**

Aunque los componentes funcionales son más comunes, las props también funcionan en componentes de clase.

**Ejemplo**:

```jsx
import React from 'react';

class Saludo extends React.Component {
  render() {
    return <h1>Hola, {this.props.nombre}!</h1>;
  }
}

// Componente padre
function App() {
  return <Saludo nombre="Sofía" />;
}
```

**Explicación**:

- En componentes de clase, las props se acceden con `this.props`.
- El resto del comportamiento es idéntico a los componentes funcionales.

**Salida**:
```
Hola, Sofía!
```

---

### 10. **Props con funciones de renderizado (Render Props Pattern)**

El patrón de "render props" consiste en pasar una función como prop que el componente hijo usa para renderizar contenido.

**Ejemplo**:

```jsx
// Componente hijo
function RenderProp({ render }) {
  const datos = { nombre: "Lucía", edad: 28 };
  return <div>{render(datos)}</div>;
}

// Componente padre
function App() {
  return (
    <RenderProp
      render={(datos) => (
        <h1>
          {datos.nombre} tiene {datos.edad} años
        </h1>
      )}
    />
  );
}
```

**Explicación**:

- La prop `render` es una función que recibe datos del componente hijo y devuelve JSX.
- Esto permite que el componente padre controle cómo se renderizan los datos del hijo.

**Salida**:
```
Lucía tiene 28 años
```

---

### 11. **Pasar múltiples props con el operador spread**

El operador spread (`...`) permite pasar múltiples props de forma concisa.

**Ejemplo**:

```jsx
// Componente hijo
function Perfil({ nombre, edad, ciudad }) {
  return (
    <div>
      <h2>{nombre}</h2>
      <p>Edad: {edad}</p>
      <p>Ciudad: {ciudad}</p>
    </div>
  );
}

// Componente padre
function App() {
  const props = { nombre: "Pedro", edad: 35, ciudad: "Madrid" };
  return <Perfil {...props} />;
}
```

**Explicación**:
- El operador spread (`...props`) descompone el objeto `props` en props individuales.
- Es equivalente a escribir `<Perfil nombre="Pedro" edad={35} ciudad="Madrid" />`.

**Salida**:
```
Pedro
Edad: 35
Ciudad: Madrid
```

---

### 12. **Props condicionales**

Puedes pasar props condicionalmente usando operadores ternarios o lógicos.

**Ejemplo**:

```jsx
// Componente hijo
function Boton({ texto, deshabilitado }) {
  return <button disabled={deshabilitado}>{texto}</button>;
}

// Componente padre
function App() {
  const estaDeshabilitado = true;
  return <Boton texto="Enviar" deshabilitado={estaDeshabilitado} />;
}
```

**Explicación**:

- La prop `deshabilitado` se pasa condicionalmente según el estado o lógica del componente padre.
- Esto permite controlar el comportamiento del componente hijo dinámicamente.

**Salida**:
Un botón con el texto "Enviar" que está deshabilitado.

---

### 13. **Props con hooks y estado**

Puedes combinar props con el estado interno del componente usando hooks como `useState`.

**Ejemplo**:

```jsx
import { useState } from 'react';

// Componente hijo
function Contador({ incremento }) {
  const [cuenta, setCuenta] = useState(0);

  const manejarClick = () => {
    setCuenta(cuenta + incremento);
  };

  return (
    <div>
      <p>Cuenta: {cuenta}</p>
      <button onClick={manejarClick}>Incrementar</button>
    </div>
  );
}

// Componente padre
function App() {
  return <Contador incremento={2} />;
}
```

**Explicación**:

- La prop `incremento` determina cuánto se incrementa el contador cada vez que se hace clic.
- El componente hijo usa `useState` para manejar su propio estado, pero la prop influye en la lógica.

**Salida**:
Un contador que empieza en 0 y aumenta en 2 con cada clic.

---

## **Buenas prácticas con props**

1. **Nombres descriptivos**: Usa nombres claros para las props (e.g., `nombre` en lugar de `n`).
2. **Validación con PropTypes**: Siempre valida las props en componentes reutilizables.
3. **Evita modificar props**: Las props son inmutables; usa el estado para datos que cambian.
4. **Desestructura cuando sea posible**: Mejora la legibilidad del código.
5. **Evita pasar demasiadas props**: Si un componente recibe muchas props, considera usar un objeto o el patrón de composición.



## Props en React con TypeScript

## Introducción

En React, los **props** son el mecanismo principal para pasar datos de un componente padre a un componente hijo. Con TypeScript, se puede añadir tipado estático para mejorar la seguridad y mantenibilidad del código, asegurando que los props tengan el tipo correcto y evitando errores en tiempo de ejecución. 

TypeScript permite definir interfaces o tipos para los props, proporcionando autocompletado, validación de tipos y mejor documentación. A continuación, se presentan ejemplos prácticos en formato MkDocs Material, en español.

---

## Configuración Básica

Para usar React con TypeScript, asegúrate de tener un proyecto configurado con las siguientes dependencias:

```bash
npm install typescript @types/react @types/react-dom
```

Los archivos de componentes deben tener la extensión `.tsx`.

---

## Definición de Props con TypeScript

Sin usar `React.FC`, definimos los props mediante una **interfaz** y tipamos explícitamente los parámetros de la función del componente.

### Ejemplo 1: Componente con Props Básicos

Un componente que muestra el nombre y la edad de una persona.

```tsx
// Definimos la interfaz para los props
interface PersonaProps {
  nombre: string;
  edad: number;
}

// Componente funcional con props tipadas
function Persona({ nombre, edad }: PersonaProps) {
  return (
    <div>
      <h2>{nombre}</h2>
      <p>Edad: {edad}</p>
    </div>
  );
}

// Uso del componente
function App() {
  return <Persona nombre="Ana" edad={25} />;
}

export default App;
```

**Explicación**:
- La interfaz `PersonaProps` define las propiedades `nombre` (string) y `edad` (number).
- En lugar de `React.FC`, tipamos los props directamente en la desestructuración de la función (`{ nombre, edad }: PersonaProps`).
- TypeScript asegura que al usar el componente `Persona`, se pasen las props con los tipos correctos.

---

## Props Opcionales

Las props opcionales se marcan con `?` en la interfaz.

### Ejemplo 2: Props Opcionales

```tsx
interface SaludoProps {
  mensaje: string;
  nombre?: string; // Prop opcional
}

function Saludo({ mensaje, nombre }: SaludoProps) {
  return (
    <div>
      <h1>{mensaje}</h1>
      {nombre && <p>Dirigido a: {nombre}</p>}
    </div>
  );
}

function App() {
  return (
    <>
      <Saludo mensaje="¡Hola, mundo!" />
      <Saludo mensaje="¡Bienvenido!" nombre="Carlos" />
    </>
  );
}

export default App;
```

**Explicación**:
- La prop `nombre` es opcional (`nombre?: string`).
- Usamos una condición (`nombre && ...`) para manejar el caso en que `nombre` no se pase.

---

## Props con Valores por Defecto

Los valores por defecto se asignan mediante desestructuración en los parámetros de la función.

### Ejemplo 3: Props con Valores por Defecto

```tsx
interface BotonProps {
  texto: string;
  color?: string;
}

function Boton({ texto, color = "azul" }: BotonProps) {
  return <button style={{ backgroundColor: color }}>{texto}</button>;
}

function App() {
  return (
    <>
      <Boton texto="Clic aquí" /> {/* Usa color por defecto: azul */}
      <Boton texto="Enviar" color="verde" />
    </>
  );
}

export default App;
```

**Explicación**:
- La prop `color` es opcional y tiene un valor por defecto de `"azul"` en la desestructuración.
- Esto elimina la necesidad de verificar si `color` existe en el componente.

---

## Props con Tipos Complejos

TypeScript permite definir props con estructuras más complejas, como objetos, arrays o funciones.

### Ejemplo 4: Props con Objetos y Funciones

```tsx
interface Producto {
  id: number;
  nombre: string;
  precio: number;
}

interface CarritoProps {
  productos: Producto[];
  onEliminar: (id: number) => void;
}

function Carrito({ productos, onEliminar }: CarritoProps) {
  return (
    <div>
      <h2>Carrito de Compras</h2>
      <ul>
        {productos.map((producto) => (
          <li key={producto.id}>
            {producto.nombre} - ${producto.precio}
            <button onClick={() => onEliminar(producto.id)}>Eliminar</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

function App() {
  const productosEjemplo: Producto[] = [
    { id: 1, nombre: "Laptop", precio: 1000 },
    { id: 2, nombre: "Teléfono", precio: 500 },
  ];

  const handleEliminar = (id: number) => {
    console.log(`Eliminando producto con ID: ${id}`);
  };

  return <Carrito productos={productosEjemplo} onEliminar={handleEliminar} />;
}

export default App;
```

**Explicación**:
- La interfaz `Producto` define la estructura de un objeto producto.
- `CarritoProps` incluye un array de productos (`productos`) y una función (`onEliminar`).
- TypeScript garantiza que la función `onEliminar` y los elementos de `productos` cumplan con los tipos definidos.

---

## Props de Componentes como Props (Children)

Los componentes pueden recibir otros componentes o elementos como props a través de `children`.

### Ejemplo 5: Usando Children

```tsx
interface ContenedorProps {
  children: React.ReactNode;
  titulo: string;
}

function Contenedor({ children, titulo }: ContenedorProps) {
  return (
    <div className="contenedor">
      <h2>{titulo}</h2>
      {children}
    </div>
  );
}

function App() {
  return (
    <Contenedor titulo="Mi Contenedor">
      <p>Este es el contenido dentro del contenedor.</p>
      <button>Acción</button>
    </Contenedor>
  );
}

export default App;
```

**Explicación**:
- La prop `children` usa el tipo `React.ReactNode`, que permite pasar cualquier contenido React válido.
- El componente `Contenedor` renderiza el título y el contenido pasado como `children`.

---


## Actividad Guiada: Uso de Props en Next.js (App Router)

Esta actividad te guiará paso a paso para entender y utilizar **props** en Next.js con el **App Router**, un concepto fundamental para pasar datos entre componentes en React. Crearemos una aplicación simple que muestra información de usuarios, utilizando componentes de cliente y servidor. La actividad está diseñada para principiantes, con explicaciones detalladas y ejemplos prácticos.

## Prerrequisitos

- Conocimientos básicos de HTML, CSS y JavaScript.
- Node.js instalado (versión 18 o superior recomendada).
- Un editor de código (como VS Code).
- Familiaridad básica con React y Next.js.
- Conocimiento básico de componentes de cliente y servidor en Next.js.

## Objetivos de la actividad

- Comprender cómo funcionan las **props** en el contexto de Next.js.
- Crear componentes de cliente que usen props para mostrar datos dinámicos.
- Practicar el paso de diferentes tipos de datos a través de props (strings, números, objetos, funciones).
- Estructurar una aplicación Next.js simple usando el App Router.

## Paso 1: Configuración del entorno

1. **Crea un fork de:**:  

   ```bash
   https://github.com/jfinfosena/act_react_s1.git
   ```


2. **Limpia el proyecto**:
   - En la carpeta `app`, elimina el contenido de `page.js` y reemplázalo con:

   ```jsx
   export default function Home() {
     return (
       <main className="container mx-auto p-4">
         <h1 className="text-3xl font-bold mb-4">Actividad de Props en Next.js</h1>
       </main>
     );
   }
   ```  

## Paso 2: Crear un componente de cliente que reciba props

1. **Crea un componente `Usuario`**:
   - Crea una nueva carpeta `components` en la raíz del proyecto.
   - Dentro de `components`, crea un archivo `Usuario.jsx`:

   ```jsx
   'use client';

   import React from 'react';

   function Usuario(props) {
     return (
       <div className="bg-gray-100 p-4 m-2 rounded-lg">
         <h2 className="text-xl font-bold">Nombre: {props.nombre}</h2>
       </div>
     );
   }

   export default Usuario;
   ```

   **Explicación**:
   - Añadimos `'use client'` al inicio del archivo porque este componente usará interactividad del lado del cliente (más adelante añadiremos un botón).
   - El componente recibe `props` y muestra la prop `nombre`.
   - Usamos Tailwind CSS para un diseño básico.

2. **Usa el componente `Usuario` en la página principal**:
   - Modifica `app/page.js`:

   ```jsx
   import Usuario from '../components/Usuario';

   export default function Home() {
     return (
       <main className="container mx-auto p-4">
         <h1 className="text-3xl font-bold mb-4">Actividad de Props en Next.js</h1>
         <Usuario nombre="Ana García" />
       </main>
     );
   }
   ```

   **Explicación**:
   - Importamos el componente `Usuario` desde la carpeta `components`.
   - Pasamos la prop `nombre` con el valor `"Ana García"`.
   - Al renderizar, el componente mostrará "Nombre: Ana García".

3. **Prueba en el navegador**:
   - Guarda los cambios y verifica que el navegador muestre el texto "Nombre: Ana García" con un estilo aplicado.

## Paso 3: Pasar múltiples props

1. **Añade más props al componente `Usuario`**:
   - Modifica `components/Usuario.jsx` para recibir y mostrar más props, como `edad` y `ciudad`:

   ```jsx
   'use client';

   import React from 'react';

   function Usuario(props) {
     return (
       <div className="bg-gray-100 p-4 m-2 rounded-lg">
         <h2 className="text-xl font-bold">Nombre: {props.nombre}</h2>
         <p>Edad: {props.edad} años</p>
         <p>Ciudad: {props.ciudad}</p>
       </div>
     );
   }

   export default Usuario;
   ```

2. **Actualiza `page.js` para pasar las nuevas props**:
   - Modifica `app/page.js`:

   ```jsx
   import Usuario from '../components/Usuario';

   export default function Home() {
     return (
       <main className="container mx-auto p-4">
         <h1 className="text-3xl font-bold mb-4">Actividad de Props en Next.js</h1>
         <Usuario nombre="Ana García" edad={25} ciudad="Madrid" />
       </main>
     );
   }
   ```

   **Explicación**:
   - Pasamos tres props: `nombre`, `edad` y `ciudad`.
   - `edad` es un número, mientras que `nombre` y `ciudad` son strings, mostrando la flexibilidad de las props.

3. **Prueba en el navegador**:
   - Verifica que se muestre el nombre, edad y ciudad correctamente.

## Paso 4: Pasar un objeto como prop

1. **Modifica `Usuario` para recibir un objeto**:
   - Actualiza `components/Usuario.jsx` para usar destructuring y recibir un objeto `usuario`:

   ```jsx
   'use client';

   import React from 'react';

   function Usuario({ usuario }) {
     return (
       <div className="bg-gray-100 p-4 m-2 rounded-lg">
         <h2 className="text-xl font-bold">Nombre: {usuario.nombre}</h2>
         <p>Edad: {usuario.edad} años</p>
         <p>Ciudad: {usuario.ciudad}</p>
       </div>
     );
   }

   export default Usuario;
   ```

   **Explicación**:
   - Usamos destructuring (`{ usuario }`) para acceder directamente al objeto `usuario`.
   - Accedemos a las propiedades con `usuario.nombre`, `usuario.edad`, etc.

2. **Actualiza `page.js` para pasar un objeto**:
   - Modifica `app/page.js`:

   ```jsx
   import Usuario from '../components/Usuario';

   export default function Home() {
     const usuario = {
       nombre: 'Ana García',
       edad: 25,
       ciudad: 'Madrid',
     };

     return (
       <main className="container mx-auto p-4">
         <h1 className="text-3xl font-bold mb-4">Actividad de Props en Next.js</h1>
         <Usuario usuario={usuario} />
       </main>
     );
   }
   ```

   **Explicación**:
   - Creamos un objeto `usuario` con las propiedades necesarias.
   - Pasamos el objeto completo como una prop llamada `usuario`.

3. **Prueba en el navegador**:
   - El resultado debe ser idéntico al paso anterior, pero usando un objeto.

## Paso 5: Pasar una función como prop

1. **Añade un botón para saludar**:
   - Modifica `components/Usuario.jsx` para incluir un botón que ejecute una función pasada como prop:

   ```jsx
   'use client';

   import React from 'react';

   function Usuario({ usuario, saludar }) {
     return (
       <div className="bg-gray-100 p-4 m-2 rounded-lg">
         <h2 className="text-xl font-bold">Nombre: {usuario.nombre}</h2>
         <p>Edad: {usuario.edad} años</p>
         <p>Ciudad: {usuario.ciudad}</p>
         <button
           className="bg-blue-500 text-white px-4 py-2 mt-2 rounded hover:bg-blue-600"
           onClick={() => saludar(usuario.nombre)}
         >
           Saludar
         </button>
       </div>
     );
   }

   export default Usuario;
   ```

   **Explicación**:
   - Añadimos una prop `saludar` que será una función.
   - Usamos un botón con `onClick` que ejecuta la función `saludar` pasando el nombre del usuario.
   - `'use client'` es necesario porque el evento `onClick` requiere interactividad del cliente.

2. **Define la función en `page.js`**:
   - Actualiza `app/page.js`:

   ```jsx
   'use client';

   import Usuario from '../components/Usuario';

   export default function Home() {
     const usuario = {
       nombre: 'Ana García',
       edad: 25,
       ciudad: 'Madrid',
     };

     const saludar = (nombre) => {
       alert(`¡Hola, ${nombre}!`);
     };

     return (
       <main className="container mx-auto p-4">
         <h1 className="text-3xl font-bold mb-4">Actividad de Props en Next.js</h1>
         <Usuario usuario={usuario} saludar={saludar} />
       </main>
     );
   }
   ```

   **Explicación**:
   - Añadimos `'use client'` a `page.js` porque definimos una función (`saludar`) que usa `alert`, una API del navegador.
   - Pasamos la función `saludar` como prop al componente `Usuario`.

3. **Prueba en el navegador**:
   - Haz clic en el botón "Saludar" y verifica que aparezca un `alert` con el mensaje "¡Hola, Ana García!".

## Paso 6: Mostrar múltiples usuarios

1. **Crea una lista de usuarios**:
   - Modifica `app/page.js` para renderizar múltiples componentes `Usuario` usando un array:

   ```jsx
   'use client';

   import Usuario from '../components/Usuario';

   export default function Home() {
     const usuarios = [
       { nombre: 'Ana García', edad: 25, ciudad: 'Madrid' },
       { nombre: 'Juan Pérez', edad: 30, ciudad: 'Barcelona' },
       { nombre: 'María López', edad: 28, ciudad: 'Valencia' },
     ];

     const saludar = (nombre) => {
       alert(`¡Hola, ${nombre}!`);
     };

     return (
       <main className="container mx-auto p-4">
         <h1 className="text-3xl font-bold mb-4">Actividad de Props en Next.js</h1>
         {usuarios.map((usuario, index) => (
           <Usuario key={index} usuario={usuario} saludar={saludar} />
         ))}
       </main>
     );
   }
   ```

   **Explicación**:
   - Usamos `map` para iterar sobre el array `usuarios` y renderizar un componente `Usuario` por cada elemento.
   - Añadimos la prop `key` para evitar advertencias de React (usamos `index` como clave, aunque en una aplicación real deberías usar un identificador único).

2. **Prueba en el navegador**:
   - Verifica que se muestren tres tarjetas de usuario con sus respectivos datos y botones de saludo.

## Paso 7: Reflexión y buenas prácticas en Next.js

- **Props son de solo lectura**: Al igual que en React, nunca modifiques las props directamente dentro de un componente.
- **Componentes de cliente vs. servidor**: En Next.js, usa `'use client'` para componentes que requieren interactividad (como eventos `onClick`). Los componentes de servidor no pueden usar props para funciones interactivas.
- **Destructuring**: Usar destructuring (`{ usuario, saludar }`) mejora la legibilidad.
- **PropTypes** (opcional): Para validar props, instala `prop-types` con `npm install prop-types` y actualiza `components/Usuario.jsx`:

   ```jsx
   'use client';

   import React from 'react';
   import PropTypes from 'prop-types';

   function Usuario({ usuario, saludar }) {
     return (
       <div className="bg-gray-100 p-4 m-2 rounded-lg">
         <h2 className="text-xl font-bold">Nombre: {usuario.nombre}</h2>
         <p>Edad: {usuario.edad} años</p>
         <p>Ciudad: {usuario.ciudad}</p>
         <button
           className="bg-blue-500 text-white px-4 py-2 mt-2 rounded hover:bg-blue-600"
           onClick={() => saludar(usuario.nombre)}
         >
           Saludar
         </button>
       </div>
     );
   }

   Usuario.propTypes = {
     usuario: PropTypes.shape({
       nombre: PropTypes.string.isRequired,
       edad: PropTypes.number.isRequired,
       ciudad: PropTypes.string.isRequired,
     }).isRequired,
     saludar: PropTypes.func.isRequired,
   };

   export default Usuario;
   ```

   **Explicación**:
   - `PropTypes` valida que las props tengan el tipo y formato esperados.
   - Si una prop falta o tiene un tipo incorrecto, aparecerá una advertencia en la consola.

- **Optimización en Next.js**:
   - Mantén los componentes de servidor siempre que sea posible para mejorar el rendimiento (por ejemplo, si no necesitas interactividad, elimina `'use client'`).
   - Usa la carpeta `app` para organizar rutas y la carpeta `components` para componentes reutilizables.

