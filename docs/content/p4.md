#  Clase 5 Agregar CSS a Componentes en Next.js

!!! info
    Este tutorial explica de forma sencilla las maneras de agregar estilos CSS a componentes en **Next.js**, excluyendo Styled-Components. Incluye ejemplos prácticos y está optimizado para MkDocs Material, con una estructura clara y ejemplos de componentes funcionales.

## Introducción

En **Next.js**, hay varias formas de aplicar estilos CSS a tus componentes React. Este tutorial cubre los métodos más comunes (excepto CSS-in-JS con Styled-Components), con ejemplos simples para que puedas entender y aplicar cada uno. Los ejemplos usan componentes funcionales y se centran en una tarjeta de usuario estilizada.

!!! note
    Asegúrate de tener una aplicación Next.js configurada (`npx create-next-app@latest`). Los ejemplos asumen que estás usando la carpeta `app` (App Router) de Next.js.

## 1. CSS Global (Archivo CSS en `/app/globals.css`)

**Explicación**: Los estilos globales se definen en un archivo CSS general (como `globals.css`) y afectan a toda la aplicación. Útil para estilos base o temas generales.

**Pasos**:

1. Usa el archivo `/app/globals.css` (creado por defecto en Next.js).
2. Importa `globals.css` en el archivo `layout.js` (ya está importado por defecto).
3. Aplica clases a tus componentes.

**Ejemplo**:

### Archivo: `app/globals.css`

```css
.tarjeta {
  border: 1px solid #ccc;
  padding: 16px;
  border-radius: 8px;
  background-color: #f9f9f9;
  text-align: center;
}

.tarjeta h2 {
  color: #007bff;
}

.tarjeta button {
  padding: 8px 16px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.tarjeta button:hover {
  background-color: #0056b3;
}
```

### Archivo: `app/page.jsx`

```jsx
export default function Home() {
  return (
    <div className="tarjeta">
      <h2>Usuario</h2>
      <p>¡Bienvenido a Next.js!</p>
      <button>Saludar</button>
    </div>
  );
}
```

!!! tip
    Los estilos globales son ideales para temas generales, pero evita usarlos para estilos específicos para no sobrecargar el archivo.

## 2. Módulos CSS (Archivos `.module.css`)

**Explicación**: Los módulos CSS permiten estilos locales y evitan conflictos al generar nombres de clases únicos. Cada componente tiene su propio archivo `.module.css`.

**Pasos**:
1. Crea un archivo CSS con la extensión `.module.css` (ejemplo: `Tarjeta.module.css`).
2. Importa el módulo en tu componente y usa las clases como propiedades de un objeto.

**Ejemplo**:

### Archivo: `app/components/Tarjeta.module.css`

```css
.tarjeta {
  border: 1px solid #ddd;
  padding: 20px;
  border-radius: 10px;
  background-color: #f0f4f8;
  text-align: center;
}

.titulo {
  color: #28a745;
  font-size: 1.5rem;
}

.boton {
  padding: 10px 20px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

.boton:hover {
  background-color: #218838;
}
```

### Archivo: `app/components/Tarjeta.jsx`

```jsx
import styles from './Tarjeta.module.css';

export default function Tarjeta({ nombre }) {
  return (
    <div className={styles.tarjeta}>
      <h2 className={styles.titulo}>{nombre}</h2>
      <p>Componente con módulo CSS</p>
      <button className={styles.boton}>Saludar</button>
    </div>
  );
}
```

### Archivo: `app/page.jsx`

```jsx
import Tarjeta from './components/Tarjeta';

export default function Home() {
  return <Tarjeta nombre="Ana" />;
}
```

!!! note
    Los módulos CSS son ideales para componentes reutilizables, ya que los estilos son locales y no afectan a otros componentes.

## 3. Estilos en Línea (Inline CSS)

**Explicación**: Los estilos en línea se aplican directamente en los elementos JSX usando el atributo `style` con un objeto JavaScript. Útil para estilos dinámicos, pero menos escalable.

**Ejemplo**:

### Archivo: `app/components/Tarjeta.jsx`

```jsx
export default function Tarjeta({ nombre }) {
  const tarjetaEstilo = {
    border: '1px solid #aaa',
    padding: '16px',
    borderRadius: '8px',
    backgroundColor: '#f9f9f9',
    textAlign: 'center',
  };

  const botonEstilo = {
    padding: '8px 16px',
    backgroundColor: '#dc3545',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
  };

  return (
    <div style={tarjetaEstilo}>
      <h2 style={{ color: '#dc3545' }}>{nombre}</h2>
      <p>Estilos en línea</p>
      <button style={botonEstilo}>Saludar</button>
    </div>
  );
}
```

!!! warning
    Los estilos en línea no admiten pseudoclases como `:hover`. Úsalos solo para casos simples o dinámicos.

## 4. Tailwind CSS (Integrado en Next.js)

**Explicación**: Tailwind CSS es una biblioteca de utilidad que permite estilizar directamente en el JSX con clases predefinidas. Next.js tiene soporte nativo para Tailwind.

**Pasos**:
1. Instala Tailwind: `npm install -D tailwindcss postcss autoprefixer`, luego ejecuta `npx tailwindcss init -p`.
2. Configura `tailwind.config.js` y añade las directivas en `app/globals.css`.
3. Usa clases de Tailwind en tus componentes.

**Ejemplo**:

### Archivo: `tailwind.config.js`

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

### Archivo: `app/globals.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

### Archivo: `app/components/Tarjeta.jsx`

```jsx
export default function Tarjeta({ nombre }) {
  return (
    <div className="border border-gray-300 p-4 rounded-lg bg-gray-50 text-center">
      <h2 className="text-2xl text-blue-600">{nombre}</h2>
      <p>Estilizado con Tailwind CSS</p>
      <button className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
        Saludar
      </button>
    </div>
  );
}
```

!!! tip
    Tailwind es ideal para desarrollo rápido y consistente. Usa la documentación oficial para explorar todas las clases disponibles.

## Ejemplo Completo con Todos los Métodos

### Archivo: `app/components/Tarjeta.jsx`

```jsx
import styles from './Tarjeta.module.css';

export default function Tarjeta({ nombre, metodo }) {
  if (metodo === 'global') {
    return (
      <div className="tarjeta">
        <h2>{nombre}</h2>
        <p>Estilos Globales</p>
        <button>Saludar</button>
      </div>
    );
  }

  if (metodo === 'modulo') {
    return (
      <div className={styles.tarjeta}>
        <h2 className={styles.titulo}>{nombre}</h2>
        <p>Estilos con Módulo CSS</p>
        <button className={styles.boton}>Saludar</button>
      </div>
    );
  }

  if (metodo === 'inline') {
    return (
      <div
        style={{
          border: '1px solid #aaa',
          padding: '16px',
          borderRadius: '8px',
          backgroundColor: '#f9f9f9',
          textAlign: 'center',
        }}
      >
        <h2 style={{ color: '#dc3545' }}>{nombre}</h2>
        <p>Estilos en Línea</p>
        <button
          style={{
            padding: '8px 16px',
            backgroundColor: '#dc3545',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          Saludar
        </button>
      </div>
    );
  }

  return (
    <div className="border border-gray-300 p-4 rounded-lg bg-gray-50 text-center">
      <h2 className="text-2xl text-blue-600">{nombre}</h2>
      <p>Estilizado con Tailwind CSS</p>
      <button className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
        Saludar
      </button>
    </div>
  );
}
```

### Archivo: `app/page.jsx`

```jsx
import Tarjeta from './components/Tarjeta';

export default function Home() {
  return (
    <div className="flex flex-wrap gap-4 p-4">
      <Tarjeta nombre="Ana" metodo="global" />
      <Tarjeta nombre="Carlos" metodo="modulo" />
      <Tarjeta nombre="María" metodo="inline" />
      <Tarjeta nombre="Luis" metodo="tailwind" />
    </div>
  );
}
```

### Archivo: `app/components/Tarjeta.module.css`

```css
.tarjeta {
  border: 1px solid #ddd;
  padding: 20px;
  border-radius: 10px;
  background-color: #f0f4f8;
  text-align: center;
}

.titulo {
  color: #28a745;
  font-size: 1.5rem;
}

.boton {
  padding: 10px 20px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

.boton:hover {
  background-color: #218838;
}
```

### Archivo: `app/globals.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

.tarjeta {
  border: 1px solid #ccc;
  padding: 16px;
  border-radius: 8px;
  background-color: #f9f9f9;
  text-align: center;
}

.tarjeta h2 {
  color: #007bff;
}

.tarjeta button {
  padding: 8px 16px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.tarjeta button:hover {
  background-color: #0056b3;
}
```

## Conclusión

- **CSS Global**: Útil para estilos generales, pero puede causar conflictos si no se organiza bien.
- **Módulos CSS**: Ideal para estilos locales y reutilizables, con nombres de clases únicos.
- **Estilos en Línea**: Bueno para casos dinámicos, pero limitado para pseudoclases como `:hover`.
- **Tailwind CSS**: Rápido y consistente, perfecto para proyectos que priorizan velocidad de desarrollo.

!!! tip
    Para proyectos grandes, combina **Módulos CSS** o **Tailwind** para mantener los estilos organizados y escalables. Evita estilos en línea para componentes complejos.


# Actividad: Creación de Componentes Funcionales y Estilizado en Next.js

!!! info
    Esta actividad está diseñada para que los estudiantes practiquen la creación de **componentes funcionales** en React (usando Next.js) en todas sus formas y apliquen diferentes métodos de estilizado CSS (global, módulos CSS, en línea y Tailwind CSS). La actividad fomenta la creatividad y el aprendizaje práctico.

## Objetivos

- Crear componentes funcionales en React usando todas las formas de declaración (función declarativa, expresada, arrow function, etc.).
- Aplicar estilos a los componentes usando **CSS global**, **módulos CSS**, **estilos en línea** y **Tailwind CSS**.
- Reforzar la comprensión de la exportación e importación de componentes en Next.js.
- Desarrollar habilidades de organización de código y documentación.


## Renderizado Dinámico de Arreglos Locales en React

## Introducción

En React, el **renderizado dinámico** es una técnica fundamental para mostrar datos de manera eficiente, especialmente cuando se trabaja con colecciones de datos como arreglos. Este proceso implica transformar un arreglo de datos en elementos JSX que se renderizan en la interfaz de usuario. Para lograr esto, se utilizan herramientas como el método `.map`, fragmentos (`<></>`) y las claves (`key`) para optimizar el rendimiento y garantizar un renderizado correcto.

En este artículo, exploraremos en detalle cómo renderizar dinámicamente arreglos locales en componentes de React, con ejemplos prácticos y explicaciones paso a paso. También proporcionaremos un ejemplo completo en formato de código que puedes integrar en un proyecto con **MkDocs Material**.

---

## Conceptos Clave

### 1. Renderizado de Listas con `.map`

El método `.map` de JavaScript es una herramienta poderosa para iterar sobre un arreglo y transformarlo en una lista de elementos JSX. En React, `.map` se utiliza comúnmente para generar componentes dinámicos a partir de un arreglo de datos.

**¿Por qué usar `.map`?**
- Permite iterar sobre un arreglo y devolver un nuevo arreglo de elementos JSX.
- Es declarativo, lo que se alinea con la filosofía de React.
- Simplifica la generación de listas dinámicas sin necesidad de bucles tradicionales como `for` o `while`.

**Ejemplo Básico:**
Supongamos que tenemos un arreglo de nombres y queremos renderizar una lista (`<ul>`) con cada nombre como un elemento (`<li>`).

```jsx
const nombres = ['Ana', 'Juan', 'María'];

function ListaNombres() {
  return (
    <ul>
      {nombres.map((nombre, index) => (
        <li key={index}>{nombre}</li>
      ))}
    </ul>
  );
}
```

**Explicación:**
- `nombres.map` recorre el arreglo `nombres` y por cada elemento devuelve un `<li>` con el nombre.
- El atributo `key={index}` asigna una clave única a cada elemento (más detalles sobre `key` más adelante).
- El resultado es una lista HTML con los nombres: Ana, Juan, María.

### 2. Uso de Fragmentos (`<></>`)

En React, cada componente debe devolver un solo elemento JSX. Cuando renderizamos listas con `.map`, a menudo necesitamos envolver los elementos generados en un contenedor, como un `<div>`. Sin embargo, esto puede agregar elementos innecesarios al DOM. Los **fragmentos** (`<></>` o `<React.Fragment>`) resuelven este problema al permitir agrupar elementos sin introducir nodos adicionales en el DOM.

**Ejemplo con Fragmentos:**
```jsx
function ListaConFragmentos() {
  const items = ['Item 1', 'Item 2', 'Item 3'];

  return (
    <>
      {items.map((item, index) => (
        <p key={index}>{item}</p>
      ))}
    </>
  );
}
```

**Explicación:**
- Los fragmentos (`<>...</>`) envuelven los elementos `<p>` sin agregar un `<div>` extra al DOM.
- Esto es útil para mantener el DOM limpio y evitar estilos no deseados causados por contenedores adicionales.

### 3. Claves (`key`) en Listas

React utiliza el atributo `key` para identificar de manera única cada elemento en una lista renderizada dinámicamente. Esto permite a React optimizar las actualizaciones del DOM al comparar elementos entre renderizados.

**Importancia de `key`:**
- Ayuda a React a determinar qué elementos han cambiado, se han agregado o eliminado.
- Mejora el rendimiento al evitar re-renderizados innecesarios.
- Debe ser único dentro de la lista y estable (es decir, no debe cambiar entre renderizados).

**Buenas Prácticas para `key`:**
- Usa un identificador único del dato, como un ID de base de datos, en lugar de índices (`index`) si es posible.
- Los índices pueden causar problemas si los elementos del arreglo cambian de orden o se eliminan.

**Ejemplo con Claves Únicas:**
Supongamos que tenemos un arreglo de objetos con IDs únicos:

```jsx
const usuarios = [
  { id: 1, nombre: 'Ana' },
  { id: 2, nombre: 'Juan' },
  { id: 3, nombre: 'María' }
];

function ListaUsuarios() {
  return (
    <ul>
      {usuarios.map((usuario) => (
        <li key={usuario.id}>{usuario.nombre}</li>
      ))}
    </ul>
  );
}
```

**Explicación:**
- `key={usuario.id}` utiliza el ID único del objeto `usuario` como clave.
- Esto asegura que React pueda rastrear cada elemento incluso si el orden del arreglo cambia.

---

## Ejemplo Completo: Aplicación de Lista de Tareas

A continuación, presentamos un ejemplo completo de una aplicación de lista de tareas que utiliza `.map`, fragmentos y claves. Este ejemplo incluye un componente React que renderiza una lista dinámica de tareas con la capacidad de agregar y eliminar tareas.

### Código del Ejemplo

```jsx
import React, { useState } from 'react';

function ListaTareas() {
  const [tareas, setTareas] = useState([
    { id: 1, texto: 'Aprender React' },
    { id: 2, texto: 'Construir una app' },
    { id: 3, texto: 'Estudiar JavaScript' }
  ]);
  const [nuevaTarea, setNuevaTarea] = useState('');

  const agregarTarea = () => {
    if (nuevaTarea.trim() === '') return;
    const nueva = {
      id: tareas.length + 1,
      texto: nuevaTarea
    };
    setTareas([...tareas, nueva]);
    setNuevaTarea('');
  };

  const eliminarTarea = (id) => {
    setTareas(tareas.filter((tarea) => tarea.id !== id));
  };

  return (
    <>
      <h1>Lista de Tareas</h1>
      <div>
        <input
          type="text"
          value={nuevaTarea}
          onChange={(e) => setNuevaTarea(e.target.value)}
          placeholder="Nueva tarea"
        />
        <button onClick={agregarTarea}>Agregar</button>
      </div>
      <ul>
        {tareas.map((tarea) => (
          <li key={tarea.id}>
            {tarea.texto}
            <button onClick={() => eliminarTarea(tarea.id)}>Eliminar</button>
          </li>
        ))}
      </ul>
    </>
  );
}

export default ListaTareas;
```

### Explicación del Ejemplo

1. **Estado Local (`useState`):**
   - `tareas` almacena el arreglo de tareas, inicializado con tres tareas de ejemplo.
   - `nuevaTarea` almacena el texto ingresado en el campo de entrada.

2. **Renderizado Dinámico con `.map`:**
   - El método `tareas.map` genera un elemento `<li>` por cada tarea en el arreglo.
   - Cada `<li>` incluye el texto de la tarea y un botón para eliminarla.

3. **Fragmentos (`<></>`):**
   - El componente devuelve un fragmento que contiene el título (`<h1>`), el formulario de entrada y la lista de tareas.
   - Esto evita agregar un `<div>` innecesario al DOM.

4. **Claves (`key`):**
   - Cada tarea utiliza su `id` como clave (`key={tarea.id}`) para garantizar un seguimiento eficiente por parte de React.

5. **Interactividad:**
   - La función `agregarTarea` añade una nueva tarea al arreglo.
   - La función `eliminarTarea` filtra las tareas para eliminar la seleccionada según su `id`.

---

## Configuración para MkDocs Material

Para integrar este contenido en un proyecto con **MkDocs Material**, asegúrate de tener un proyecto MkDocs configurado. A continuación, se explica cómo incluir el ejemplo en tu documentación.

### Estructura del Proyecto

```
mkdocs-project/
├── docs/
│   ├── index.md
│   ├── renderizado_dinamico_react.md
├── mkdocs.yml
```

### Configuración de `mkdocs.yml`

Asegúrate de que tu archivo `mkdocs.yml` incluya el tema **Material** y habilite el resaltado de código para JSX:

```yaml
site_name: Guía de React
theme:
  name: material
  features:
    - content.code.copy
markdown_extensions:
  - pymdownx.highlight:
      anchor_linenums: true
  - pymdownx.superfences
  - pymdownx.tabbed
```

### Guardar el Contenido

Guarda el contenido de este artículo en `docs/renderizado_dinamico_react.md`. Luego, ejecuta `mkdocs serve` para visualizar la documentación localmente.

---

## Mejores Prácticas

1. **Usa Claves Únicas y Estables:**
   - Evita usar índices como claves si los elementos del arreglo pueden cambiar de orden o eliminarse.
   - Prefiere identificadores únicos como IDs generados por una base de datos o una librería como `uuid`.

2. **Minimiza Elementos en el DOM:**
   - Usa fragmentos (`<></>`) en lugar de `<div>` innecesarios para mantener el DOM limpio.

3. **Optimiza el Rendimiento:**
   - Si la lista es grande, considera usar técnicas como paginación o virtualización (por ejemplo, con `react-window`).
   - Evita realizar operaciones costosas dentro de `.map`.

4. **Valida los Datos:**
   - Asegúrate de que los datos del arreglo sean válidos antes de renderizarlos para evitar errores.

---
