<<<<<<< HEAD
# Semana 9: Hook useState - Guía Simple y Detallada

## ¿Qué es useState?

El hook `useState` es la forma más simple de agregar **estado** a un componente funcional en React. Piensa en el estado como la "memoria" de tu componente - información que puede cambiar y que React necesita recordar.

### Concepto Simple
```jsx
const [valor, setValor] = useState(valorInicial);
```

- `valor`: Lo que queremos recordar
- `setValor`: Función para cambiar ese valor
- `valorInicial`: El valor al inicio

## Importación

Siempre debemos importar useState antes de usarlo:

```jsx
import { useState } from 'react';
```

## Ejemplo 1: Mi Primer Estado

Comencemos con algo súper simple - un contador:

```jsx
import { useState } from 'react';

function MiContador() {
  // Creamos un estado que empieza en 0
  const [numero, setNumero] = useState(0);

  return (
    <div>
      <h2>El número es: {numero}</h2>
      <button onClick={() => setNumero(numero + 1)}>
        Sumar 1
      </button>
    </div>
  );
}
```

**¿Qué pasa aquí?**
1. `useState(0)` crea un estado que empieza en 0
2. `numero` contiene el valor actual
3. `setNumero` es la función para cambiarlo
4. Cuando hacemos clic, `setNumero(numero + 1)` aumenta el número
5. React automáticamente actualiza la pantalla

## Ejemplo 2: Texto que Cambia

Ahora veamos cómo manejar texto:

```jsx
function SaludoPersonalizado() {
  const [nombre, setNombre] = useState('');

  return (
    <div>
      <input 
        type="text"
        value={nombre}
        onChange={(e) => setNombre(e.target.value)}
        placeholder="Escribe tu nombre"
      />
      <h2>¡Hola {nombre}!</h2>
    </div>
  );
}
```

**Explicación paso a paso:**
1. `useState('')` crea un estado de texto vacío
2. `value={nombre}` conecta el input con nuestro estado
3. `onChange` se ejecuta cada vez que escribimos
4. `e.target.value` es lo que escribió el usuario
5. `setNombre(e.target.value)` actualiza nuestro estado

## Tipos de Estados Comunes

### 1. Números
```jsx
function Calculadora() {
  const [precio, setPrecio] = useState(0);
  const [cantidad, setCantidad] = useState(1);
  
  const total = precio * cantidad;

  return (
    <div>
      <input 
        type="number" 
        value={precio}
        onChange={(e) => setPrecio(Number(e.target.value))}
        placeholder="Precio"
      />
      <input 
        type="number" 
        value={cantidad}
        onChange={(e) => setCantidad(Number(e.target.value))}
        placeholder="Cantidad"
      />
      <h3>Total: ${total}</h3>
    </div>
  );
}
```

### 2. Verdadero/Falso (Boolean)
```jsx
function Interruptor() {
  const [encendido, setEncendido] = useState(false);

  return (
    <div>
      <button onClick={() => setEncendido(!encendido)}>
        {encendido ? 'Apagar' : 'Encender'}
      </button>
      <p>La luz está {encendido ? 'encendida' : 'apagada'}</p>
    </div>
  );
}
```

### 3. Listas (Arrays)
```jsx
function ListaTareas() {
  const [tareas, setTareas] = useState([]);
  const [nuevaTarea, setNuevaTarea] = useState('');

  const agregarTarea = () => {
    if (nuevaTarea.trim()) {
      setTareas([...tareas, nuevaTarea]);
      setNuevaTarea('');
    }
  };

  return (
    <div>
      <input 
        value={nuevaTarea}
        onChange={(e) => setNuevaTarea(e.target.value)}
        placeholder="Nueva tarea"
      />
      <button onClick={agregarTarea}>Agregar</button>
      
      <ul>
        {tareas.map((tarea, index) => (
          <li key={index}>{tarea}</li>
        ))}
      </ul>
=======
#  Clase 6: Renderizado Dinámico de Arreglos Locales en React y Next.js

El renderizado dinámico de arreglos locales es una práctica común en **React** y **Next.js** para mostrar listas de datos en la interfaz de usuario. Esto se logra principalmente utilizando el método `.map()` de JavaScript, fragmentos (`<></>`) para agrupar elementos sin nodos adicionales en el DOM, y la prop `key` para optimizar el rendimiento y evitar problemas de reconciliación en el DOM virtual. Este documento explica en detalle cómo implementar el renderizado dinámico de arreglos locales en componentes de React dentro de un proyecto Next.js, incluyendo ejemplos prácticos, buenas prácticas y el uso de **Tailwind CSS** para estilos. Los ejemplos se basan en una aplicación de tienda en línea que muestra una lista de productos.

---

## Conceptos clave

### 1. Renderizado dinámico con `.map()`
El método `.map()` de JavaScript itera sobre un arreglo y devuelve un nuevo arreglo con los elementos transformados. En React, se usa para generar elementos JSX dinámicamente a partir de un arreglo de datos.

- **Uso**: Transforma cada elemento del arreglo en un componente o elemento JSX.
- **Ejemplo**: `array.map(item => <div>{item}</div>)`

### 2. Fragmentos (`<></>` o `<React.Fragment>`)
Los fragmentos permiten agrupar múltiples elementos JSX sin introducir un nodo adicional en el DOM (como un `<div>`).

- **Uso**: Envolver múltiples elementos devueltos por `.map()` para cumplir con la regla de React de devolver un solo elemento.
- **Ventaja**: Reduce el clutter en el DOM, mejorando el rendimiento y la semántica.
- **Ejemplo**: `<>{array.map(item => <div>{item}</div>)}</>`

### 3. Prop `key`
La prop `key` es un identificador único que React usa para optimizar la reconciliación del DOM virtual, evitando renders innecesarios y manteniendo el estado de los componentes.

- **Uso**: Se asigna a cada elemento generado por `.map()` usando un valor único (como un ID).
- **Regla**: No uses índices del arreglo (`index`) como `key` si los datos pueden cambiar (ordenar, agregar, eliminar), ya que puede causar problemas de rendimiento o comportamiento inesperado.
- **Ejemplo**: `<div key={item.id}>{item.nombre}</div>`

---

## Configuración del proyecto en Next.js

Antes de los ejemplos, configuraremos un proyecto Next.js con Tailwind CSS para estilizar los componentes.

### Crear un proyecto Next.js

1. Crea un nuevo proyecto Next.js:
   ```bash
   npx create-next-app@latest mi-tienda
   cd mi-tienda
   ```

2. Instala Tailwind CSS:
   ```bash
   npm install -D tailwindcss postcss autoprefixer
   npx tailwindcss init -p
   ```

3. Configura `tailwind.config.js`:
   ```javascript
   /** @type {import('tailwindcss').Config} */
   module.exports = {
     content: [
       "./app/**/*.{js,ts,jsx,tsx}",
       "./pages/**/*.{js,ts,jsx,tsx}",
       "./components/**/*.{js,ts,jsx,tsx}",
     ],
     theme: {
       extend: {},
     },
     plugins: [],
   }
   ```

4. Agrega las directivas de Tailwind en `app/globals.css`:
   ```css
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   ```

5. Asegúrate de que `package.json` incluya las dependencias necesarias:
   ```json
   {
     "dependencies": {
       "next": "14.2.14",
       "react": "18.3.1",
       "react-dom": "18.3.1"
     },
     "devDependencies": {
       "tailwindcss": "^3.4.13",
       "postcss": "^8.4.47",
       "autoprefixer": "^10.4.20"
     }
   }
   ```

---

## Ejemplo práctico: Lista de productos

Crearemos un componente que renderiza dinámicamente una lista de productos almacenada en un arreglo local. Usaremos `.map()`, fragmentos, y la prop `key`, con estilos de Tailwind CSS.

### Código del componente

#### Archivo: `components/ProductList.jsx`

```jsx
import React from 'react';

const products = [
  { id: 1, name: 'Laptop', price: 999.99, category: 'Electrónica' },
  { id: 2, name: 'Smartphone', price: 699.99, category: 'Electrónica' },
  { id: 3, name: 'Zapatillas', price: 89.99, category: 'Moda' },
  { id: 4, name: 'Libro', price: 19.99, category: 'Libros' },
];

const ProductList = () => {
  return (
    <div className="max-w-4xl mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6 text-center">Lista de Productos</h1>
      <>
        {products.map((product) => (
          <div
            key={product.id}
            className="bg-white shadow-md rounded-lg p-4 mb-4 flex justify-between items-center"
          >
            <div>
              <h2 className="text-xl font-semibold">{product.name}</h2>
              <p className="text-gray-600">Categoría: {product.category}</p>
            </div>
            <p className="text-lg font-bold text-green-600">${product.price.toFixed(2)}</p>
          </div>
        ))}
      </>
    </div>
  );
};

export default ProductList;
```

#### Archivo: `app/page.jsx`

```jsx
import ProductList from '../components/ProductList';

export default function Home() {
  return (
    <main>
      <ProductList />
    </main>
  );
}
```

### Explicación del ejemplo

- **Arreglo local** (`products`):
  - Definimos un arreglo estático de objetos que representan productos, cada uno con `id`, `name`, `price` y `category`.
  - En un escenario real, este arreglo podría provenir de una API o base de datos.

- **Uso de `.map()`**:
  - Iteramos sobre `products` con `.map()` para generar un `<div>` por cada producto.
  - Cada `<div>` muestra el nombre, categoría y precio del producto.

- **Fragmentos (`<></>`)**:
  - Envolvemos los elementos generados por `.map()` en un fragmento (`<></>`) para cumplir con la regla de React de devolver un solo elemento raíz.
  - Esto evita agregar un `<div>` innecesario en el DOM.

- **Prop `key`**:
  - Usamos `key={product.id}` para asignar un identificador único a cada `<div>`.
  - El `id` es único y estable, lo que ayuda a React a rastrear los elementos y optimizar las actualizaciones.

- **Estilos con Tailwind CSS**:
  - Usamos clases de Tailwind como `max-w-4xl`, `mx-auto`, `p-4`, `shadow-md`, etc., para centrar el contenido, agregar sombras, bordes redondeados y estilos responsivos.
  - Los productos se muestran en tarjetas con un diseño limpio y moderno.

- **Estructura del DOM**:
  - El componente genera una lista de tarjetas, cada una representando un producto, sin nodos adicionales gracias al fragmento.

---

## Variaciones y casos avanzados

### 1. Renderizado condicional dentro de `.map()`
A veces, necesitas renderizar elementos solo si cumplen ciertas condiciones. Por ejemplo, mostrar solo productos de una categoría específica.

#### Código

```jsx
import React from 'react';

const products = [
  { id: 1, name: 'Laptop', price: 999.99, category: 'Electrónica' },
  { id: 2, name: 'Smartphone', price: 699.99, category: 'Electrónica' },
  { id: 3, name: 'Zapatillas', price: 89.99, category: 'Moda' },
  { id: 4, name: 'Libro', price: 19.99, category: 'Libros' },
];

const ProductList = () => {
  return (
    <div className="max-w-4xl mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6 text-center">Productos Electrónicos</h1>
      <>
        {products.map((product) =>
          product.category === 'Electrónica' ? (
            <div
              key={product.id}
              className="bg-white shadow-md rounded-lg p-4 mb-4 flex justify-between items-center"
            >
              <div>
                <h2 className="text-xl font-semibold">{product.name}</h2>
                <p className="text-gray-600">Categoría: {product.category}</p>
              </div>
              <p className="text-lg font-bold text-green-600">${product.price.toFixed(2)}</p>
            </div>
          ) : null
        )}
      </>
    </div>
  );
};

export default ProductList;
```

#### Explicación
- **Condicional**: Dentro de `.map()`, usamos un operador ternario (`?:`) para renderizar solo los productos de la categoría "Electrónica". Si la condición no se cumple, devolvemos `null`, lo que no genera ningún elemento en el DOM.
- **Fragmentos**: Seguimos usando `<></>` para envolver los elementos generados.
- **Key**: Cada elemento renderizado tiene un `key` basado en `product.id`.

---

### 2. Componente reutilizable para cada elemento
Para mejorar la modularidad, podemos extraer la lógica de renderizado de cada producto a un componente separado.

#### Código

```jsx
// components/ProductItem.jsx
import React from 'react';

const ProductItem = ({ product }) => {
  return (
    <div className="bg-white shadow-md rounded-lg p-4 mb-4 flex justify-between items-center">
      <div>
        <h2 className="text-xl font-semibold">{product.name}</h2>
        <p className="text-gray-600">Categoría: {product.category}</p>
      </div>
      <p className="text-lg font-bold text-green-600">${product.price.toFixed(2)}</p>
    </div>
  );
};

export default ProductItem;

// components/ProductList.jsx
import React from 'react';
import ProductItem from './ProductItem';

const products = [
  { id: 1, name: 'Laptop', price: 999.99, category: 'Electrónica' },
  { id: 2, name: 'Smartphone', price: 699.99, category: 'Electrónica' },
  { id: 3, name: 'Zapatillas', price: 89.99, category: 'Moda' },
  { id: 4, name: 'Libro', price: 19.99, category: 'Libros' },
];

const ProductList = () => {
  return (
    <div className="max-w-4xl mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6 text-center">Lista de Productos</h1>
      <>
        {products.map((product) => (
          <ProductItem key={product.id} product={product} />
        ))}
      </>
    </div>
  );
};

export default ProductList;
```

#### Explicación
- **Componente `ProductItem`**: Encapsula la lógica de renderizado de un solo producto, recibiendo `product` como prop.
- **Reutilización**: `ProductList` usa `ProductItem` dentro de `.map()`, pasando cada `product` como prop.
- **Key**: La prop `key` se asigna en el nivel de `ProductItem` para mantener la optimización.
- **Ventajas**: Mejora la mantenibilidad y permite reutilizar `ProductItem` en otros contextos.

---

### 3. Manejo de arreglos vacíos
Es importante manejar casos donde el arreglo esté vacío para evitar mostrar una lista vacía sin retroalimentación al usuario.

#### Código

```jsx
import React from 'react';
import ProductItem from './ProductItem';

const products = []; // Arreglo vacío para este ejemplo

const ProductList = () => {
  return (
    <div className="max-w-4xl mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6 text-center">Lista de Productos</h1>
      {products.length === 0 ? (
        <p className="text-center text-gray-500">No hay productos disponibles.</p>
      ) : (
        <>
          {products.map((product) => (
            <ProductItem key={product.id} product={product} />
          ))}
        </>
      )}
    </div>
  );
};

export default ProductList;
```

#### Explicación
- **Condicional**: Usamos un operador ternario para verificar si `products.length === 0`. Si está vacío, mostramos un mensaje; si no, renderizamos la lista.
- **Fragmentos**: Cuando hay productos, usamos `<></>` para envolver los elementos generados por `.map()`.
- **Buena práctica**: Siempre proporcionar retroalimentación al usuario cuando no hay datos.

---

## Tutorial: Condicionales en React con JavaScript y Operador Ternario

## Introducción

En React, las condicionales son fundamentales para crear interfaces dinámicas que respondan al estado de la aplicación. Este tutorial te enseñará a usar funciones declarativas puras junto con JavaScript nativo para crear componentes que rendericen contenido de manera condicional.

Aprenderás a:
- Usar el operador ternario para renderizado condicional
- Implementar lógica compleja con JavaScript en JSX
- Crear funciones declarativas que reciban props
- Aplicar estilos dinámicos basados en condiciones
- Procesar datos usando métodos de arrays nativos

## 1. Fundamentos del Renderizado Condicional

### Operador Ternario Básico

El operador ternario es la forma más común de renderizado condicional en React:

```jsx
function MensajeBienvenida({ usuario }) {
  return (
    <div>
      {usuario ? (
        <h1>¡Bienvenido, {usuario.nombre}!</h1>
      ) : (
        <h1>Por favor, inicia sesión</h1>
      )}
>>>>>>> a81cd25f3f0a77b540c85aeb6dda168a25cb7db7
    </div>
  );
}
```

<<<<<<< HEAD
**Punto importante:** `[...tareas, nuevaTarea]` crea una nueva lista con todos los elementos anteriores más el nuevo. ¡Nunca modifiques la lista directamente!

### 4. Objetos
```jsx
function PerfilUsuario() {
  const [usuario, setUsuario] = useState({
    nombre: '',
    edad: 0,
    email: ''
  });

  const actualizarNombre = (nuevoNombre) => {
    setUsuario({
      ...usuario,  // Mantener todo lo anterior
      nombre: nuevoNombre  // Cambiar solo el nombre
    });
  };

  return (
    <div>
      <input 
        value={usuario.nombre}
        onChange={(e) => actualizarNombre(e.target.value)}
        placeholder="Nombre"
      />
      <p>Hola {usuario.nombre}</p>
=======
### Renderizado Condicional con &&

Para mostrar algo solo cuando una condición es verdadera:

```jsx
function NotificacionError({ error }) {
  return (
    <div>
      {error && (
        <div style={{ color: 'red', padding: '10px', border: '1px solid red' }}>
          Error: {error}
        </div>
      )}
>>>>>>> a81cd25f3f0a77b540c85aeb6dda168a25cb7db7
    </div>
  );
}
```

<<<<<<< HEAD
## Reglas Importantes

### ❌ NO hagas esto:
```jsx
// MAL - Modificar directamente
const [lista, setLista] = useState([1, 2, 3]);
lista.push(4);  // ¡NO!
setLista(lista);

// MAL - Modificar objeto directamente
const [persona, setPersona] = useState({nombre: 'Juan'});
persona.nombre = 'Pedro';  // ¡NO!
setPersona(persona);
```

### ✅ SÍ haz esto:
```jsx
// BIEN - Crear nueva lista
const [lista, setLista] = useState([1, 2, 3]);
setLista([...lista, 4]);

// BIEN - Crear nuevo objeto
const [persona, setPersona] = useState({nombre: 'Juan'});
setPersona({...persona, nombre: 'Pedro'});
```

## Ejemplo Práctico: Formulario Simple

```jsx
function FormularioContacto() {
  const [datos, setDatos] = useState({
    nombre: '',
    email: '',
    mensaje: ''
  });
  const [enviado, setEnviado] = useState(false);

  const manejarCambio = (campo, valor) => {
    setDatos({
      ...datos,
      [campo]: valor
    });
  };

  const enviarFormulario = () => {
    console.log('Datos enviados:', datos);
    setEnviado(true);
  };

  if (enviado) {
    return <h2>¡Mensaje enviado! Gracias {datos.nombre}</h2>;
  }

  return (
    <div>
      <h2>Contáctanos</h2>
      
      <input 
        type="text"
        value={datos.nombre}
        onChange={(e) => manejarCambio('nombre', e.target.value)}
        placeholder="Tu nombre"
      />
      
      <input 
        type="email"
        value={datos.email}
        onChange={(e) => manejarCambio('email', e.target.value)}
        placeholder="Tu email"
      />
      
      <textarea 
        value={datos.mensaje}
        onChange={(e) => manejarCambio('mensaje', e.target.value)}
        placeholder="Tu mensaje"
      />
      
      <button onClick={enviarFormulario}>
        Enviar
=======
## 2. JavaScript Avanzado en JSX

### Cálculos y Manipulación de Datos

```jsx
function EjemploJavaScript({ datos = [] }) {
  // Cálculos usando JavaScript nativo
  const fechaActual = new Date();
  const horaActual = fechaActual.getHours();
  const saludo = horaActual < 12 ? 'Buenos días' : horaActual < 18 ? 'Buenas tardes' : 'Buenas noches';
  
  // Procesamiento de arrays
  const numerosPositivos = datos.filter(num => num > 0);
  const suma = numerosPositivos.reduce((acc, num) => acc + num, 0);
  const promedio = numerosPositivos.length > 0 ? suma / numerosPositivos.length : 0;
  
  // Manipulación de strings
  const textoFormateado = `Hoy es ${fechaActual.toLocaleDateString('es-ES')}`;
  
  return (
    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>
      <h2>{saludo} 👋</h2>
      <p>{textoFormateado}</p>
      
      {datos.length > 0 ? (
        <div>
          <p>Datos recibidos: {datos.join(', ')}</p>
          <p>Números positivos: {numerosPositivos.join(', ')}</p>
          <p>Suma: {suma}</p>
          <p>Promedio: {promedio.toFixed(2)}</p>
        </div>
      ) : (
        <p>No hay datos para mostrar</p>
      )}
      
      {/* Condicional basada en la hora */}
      <div style={{
        backgroundColor: horaActual < 6 || horaActual > 20 ? '#2c3e50' : '#3498db',
        color: 'white',
        padding: '10px',
        borderRadius: '5px',
        marginTop: '10px'
      }}>
        {horaActual < 6 || horaActual > 20 ? '🌙 Modo nocturno' : '☀️ Modo diurno'}
      </div>
    </div>
  );
}
```

## 3. Ejemplo Práctico

### Sistema de Autenticación

```jsx
function AppLogin({ usuario, onLogin, onLogout }) {
  return (
    <div style={{ maxWidth: '400px', margin: '0 auto', padding: '20px' }}>
      <h1>Mi Aplicación</h1>
      {usuario ? (
        <ComponenteBienvenida usuario={usuario} onLogout={onLogout} />
      ) : (
        <ComponenteLogin onLogin={onLogin} />
      )}
    </div>
  );
}

function ComponenteBienvenida({ usuario, onLogout }) {
  const tiempoConectado = Date.now() - usuario.tiempoLogin;
  const minutosConectado = Math.floor(tiempoConectado / (1000 * 60));
  const esUsuarioVIP = usuario.tipo === 'premium';
  
  return (
    <div style={{
      backgroundColor: esUsuarioVIP ? '#f8f9fa' : '#ffffff',
      border: esUsuarioVIP ? '2px solid #ffd700' : '1px solid #dee2e6',
      borderRadius: '8px',
      padding: '20px'
    }}>
      <h2>¡Bienvenido, {usuario.nombre}! {esUsuarioVIP && '👑'}</h2>
      <p>Email: {usuario.email}</p>
      <p>Tiempo conectado: {minutosConectado} minutos</p>
      
      {esUsuarioVIP && (
        <div style={{ backgroundColor: '#fff3cd', padding: '10px', borderRadius: '5px', marginBottom: '10px' }}>
          🌟 Tienes acceso a funciones premium
        </div>
      )}
      
      <button 
        onClick={onLogout}
        style={{
          backgroundColor: '#dc3545',
          color: 'white',
          border: 'none',
          padding: '10px 20px',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
      >
        Cerrar Sesión
      </button>
    </div>
  );
}

function ComponenteLogin({ onLogin }) {
  const handleLogin = () => {
    const usuarioDemo = {
      nombre: 'Juan Pérez',
      email: 'juan@ejemplo.com',
      tipo: Math.random() > 0.5 ? 'premium' : 'regular',
      tiempoLogin: Date.now()
    };
    onLogin(usuarioDemo);
  };
  
  return (
    <div style={{ textAlign: 'center' }}>
      <h2>Iniciar Sesión</h2>
      <p>Haz clic para acceder con un usuario demo</p>
      <button 
        onClick={handleLogin}
        style={{
          backgroundColor: '#28a745',
          color: 'white',
          border: 'none',
          padding: '12px 24px',
          borderRadius: '5px',
          cursor: 'pointer',
          fontSize: '16px'
        }}
      >
        Acceder
>>>>>>> a81cd25f3f0a77b540c85aeb6dda168a25cb7db7
      </button>
    </div>
  );
}
```

<<<<<<< HEAD
## Consejos Prácticos

### 1. Múltiples Estados
Puedes tener varios estados en un componente:

```jsx
function MiComponente() {
  const [nombre, setNombre] = useState('');
  const [edad, setEdad] = useState(0);
  const [activo, setActivo] = useState(false);
  
  // ... resto del componente
}
```

### 2. Estado Inicial Calculado
Si el valor inicial requiere cálculo, usa una función:

```jsx
const [datos, setDatos] = useState(() => {
  // Esto solo se ejecuta una vez
  return JSON.parse(localStorage.getItem('datos')) || [];
});
```

### 3. Actualización Basada en Estado Anterior
Cuando el nuevo valor depende del anterior, usa una función:

```jsx
const [contador, setContador] = useState(0);

// Mejor práctica
const incrementar = () => {
  setContador(prevContador => prevContador + 1);
};
```

## Ejercicios para Practicar

### Ejercicio 1: Contador Avanzado
Crea un contador que:
- Pueda sumar y restar
- Tenga un botón de reset
- Muestre si el número es par o impar

### Ejercicio 2: Lista de Compras
Crea una lista donde puedas:
- Agregar productos
- Eliminar productos
- Marcar como comprado

### Ejercicio 3: Calculadora de Propinas
Crea una calculadora que:
- Reciba el total de la cuenta
- Permita elegir porcentaje de propina
- Calcule el total final
=======





>>>>>>> a81cd25f3f0a77b540c85aeb6dda168a25cb7db7
